package deviceapi

import (
	"errors"
	"github.com/niklas88/feel-at-home-server/devices"
	"sync"
)

// Registry is the type used to handle registration of effects registered
// effects can then automatically be paired with compatible devices
type Registry struct {
	sync.RWMutex
	r map[string]Effect
}

// DefaultRegistry is the default package History and for many applications no
// other Registry needs to be created
var DefaultRegistry *Registry

// NewRegistry creates a new Registry, usually using the DefaultRegistry should
// be preferred
func NewRegistry() *Registry {
	return &Registry{r: make(map[string]Effect)}
}

func init() {
	DefaultRegistry = NewRegistry()
}

// Register registers an effect and populates the current, though usually
// inactive, effect config with the default generated by the registered
// ConfigFactory
func (r *Registry) Register(eff Effect) error {
	r.Lock()
	defer r.Unlock()
	if _, ok := r.r[eff.Name()]; ok {
		return errors.New("Tried adding two effects under Name " + eff.Name())
	}
	r.r[eff.Name()] = eff
	return nil
}

// Effect finds an effect in the registry by name.
// If the effect doesn't exist the function returns nil
func (r *Registry) Effect(name string) Effect {
	r.RLock()
	defer r.RUnlock()
	eff, ok := r.r[name]
	if !ok {
		return nil
	}

	return eff
}

// CompatibleEffects returns a slice of all compatible effects for the given
// device
func (r *Registry) CompatibleEffects(lamp devices.Device) []Effect {
	compatibles := make([]Effect, 0, 10)
	r.RLock()
	defer r.RUnlock()
	for _, eff := range r.r {
		if eff.Compatible(lamp) {
			compatibles = append(compatibles, eff)
		}
	}
	return compatibles
}
