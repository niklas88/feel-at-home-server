package effect

import (
	"errors"
	"fmt"
	"github.com/niklas88/feel-at-home-server/lampbase"
	"sync"
)

// Registry is the type used to handle registration of effects registered
// effects can then automatically be paired with compatible devices
type Registry struct {
	sync.RWMutex
	r map[string]*Registration
}

// Registration holds both metadata about a registered effect and also stores
// the ConfigFactory that may be used to generate default configurations for
// this effect. Usually all fields in the generated config can be customized
type Registration struct {
	Info          Info
	EffectFactory interface{}
	ConfigFactory func() Config
}

// Compatible checks whether a particular Registration is compatible with the
// given device
func (e *Registration) Compatible(lamp lampbase.Device) bool {
	switch fac := e.EffectFactory.(type) {
	case DeviceEffectFactory:
		_, ok := lamp.(lampbase.Device)
		return ok
	case DimLampEffectFactory:
		_, ok := lamp.(lampbase.DimLamp)
		return ok
	case ColorLampEffectFactory:
		_, ok := lamp.(lampbase.ColorLamp)
		return ok
	case StripeLampEffectFactory:
		_, ok := lamp.(lampbase.StripeLamp)
		return ok
	case MatrixLampEffectFactory:
		_, ok := lamp.(lampbase.MatrixLamp)
		return ok
	case WordClockEffectFactory:
		_, ok := lamp.(lampbase.WordClock)
		return ok
	default:
		panic("Unknow effect type " + fmt.Sprintf("%g", fac))
	}
}

// DefaultRegistry is the default package History and for many applications no
// other Registry needs to be created
var DefaultRegistry *Registry

// NewRegistry creates a new Registry, usually using the DefaultRegistry should
// be preferred
func NewRegistry() *Registry {
	return &Registry{r: make(map[string]*Registration)}
}

func init() {
	DefaultRegistry = NewRegistry()
}

// Register registers an effect and populates the current, though usually
// inactive, effect config with the default generated by the registered
// ConfigFactory
func (r *Registry) Register(reg *Registration) error {
	r.Lock()
	defer r.Unlock()
	info := reg.Info
	if _, ok := r.r[info.Name]; ok {
		return errors.New("Tried adding two effects under Name " + info.Name)
	}
	// Populate Config with default
	reg.Info.Config = reg.ConfigFactory()
	r.r[info.Name] = reg
	return nil
}

// Effect finds an effect in the registry by name and checks its compatibility
// with the given device.  If the effect doesn't exist or is incompatible with
// the given device this function returns nil
func (r *Registry) Effect(name string, device lampbase.Device) Effect {
	r.RLock()
	defer r.RUnlock()
	e, ok := r.r[name]
	if !ok {
		return nil
	}
	var eff Effect
	switch fac := e.EffectFactory.(type) {
	case DeviceEffectFactory:
		eff = fac(device)
	case DimLampEffectFactory:
		d, ok := device.(lampbase.DimLamp)
		if !ok {
			return nil
		}
		eff = fac(d)
	case ColorLampEffectFactory:
		d, ok := device.(lampbase.ColorLamp)
		if !ok {
			return nil
		}
		eff = fac(d)
	case StripeLampEffectFactory:
		d, ok := device.(lampbase.StripeLamp)
		if !ok {
			return nil
		}
		eff = fac(d)
	case MatrixLampEffectFactory:
		d, ok := device.(lampbase.MatrixLamp)
		if !ok {
			return nil
		}
		eff = fac(d)
	case WordClockEffectFactory:
		d, ok := device.(lampbase.WordClock)
		if !ok {
			return nil
		}
		eff = fac(d)
	default:
		panic("Unknow effect factory type " + fmt.Sprintf("%q", eff))
	}

	return eff
}

// CompatibleEffects returns a slice of all compatible effects for the given
// device
func (r *Registry) CompatibleEffects(lamp lampbase.Device) []Info {
	compatibles := make([]Info, 0, 10)
	r.RLock()
	defer r.RUnlock()
	for _, v := range r.r {
		if v.Compatible(lamp) {
			compatibles = append(compatibles, v.Info)
		}
	}
	return compatibles
}

// Info returns the information on the effect registered under the given name
// or nil if no such effect exists
func (r *Registry) Info(name string) *Info {
	r.RLock()
	defer r.RUnlock()
	v, ok := r.r[name]
	if !ok {
		return nil
	}
	info := v.Info
	info.Config = v.ConfigFactory()
	return &info
}

// Config creates a default config for the effect registered under the given
// name or nil if no such effect exists
func (r *Registry) Config(name string) Config {
	r.RLock()
	defer r.RUnlock()
	v, ok := r.r[name]
	if !ok {
		return nil
	}
	return v.ConfigFactory()
}
